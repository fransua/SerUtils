from itertools import izip_longest

import numpy as np
from matplotlib import pyplot as plt


def nucleotide_content(seqs, letters=('A', 'T', 'G', 'C', 'N'), remove_gap_only=True, min_count=1):
    """
    :params None seqs: list of sequences
    :param 'A', 'T', 'G', 'C', 'N' letters: nucleotides to consider

    :returns: list of dictionaries of nucleotide proportions per sequence.
    """
    seq_count = []
    col_count = []
    lencol = float(len(seqs))
    for col in izip_longest(*seqs, fillvalue='N'):
        nchars = lencol - col.count('-')
        if nchars < min_count:
            if not remove_gap_only:
                seq_count.append(dict([(let, 0) for let in letters]))
                col_count.append(nchars)
            continue
        col_count.append(nchars)
        seq_count.append(dict([(let, col.count(let) / nchars) for let in letters]))
    return seq_count, col_count


def seq_logo(seqs=None, seq_count=None, letters=('A', 'T', 'G', 'C', 'N'),
             nseq=None, title='', axe=None, quality=1, plot=True, ylim=(0, 2),
             lwmodif=1.25, remove_gap_only=True, min_count=1, errorbar=True, savefig=None):
    """
    Draw a sequence motif according to an input list of sequences,
    https://en.wikipedia.org/wiki/Sequence_logo

    :params None seqs: list of sequences
    :params None seq_count: list of dictionaries of nucleotide proportions per
        sequence (generated by nucleotide_content function) in the form:
        [{'A': 0.29, 'C': 0.22, 'T': 0.24, 'G': 0.25, 'N': 0.0},
         {'A': 0.26, 'C': 0.27, 'T': 0.24, 'G': 0.23, 'N': 0.0},
         {'A': 0.32, 'C': 0.25, 'T': 0.17, 'G': 0.26, 'N': 0.0},
         {'A': 0.32, 'C': 0.24, 'T': 0.21, 'G': 0.23, 'N': 0.0},
         {'A': 0.29, 'C': 0.21, 'T': 0.25, 'G': 0.25, 'N': 0.0},
         {'A': 0.25, 'C': 0.28, 'T': 0.26, 'G': 0.21, 'N': 0.0},
         {'A': 0.21, 'C': 0.25, 'T': 0.34, 'G': 0.20, 'N': 0.0},
         {'A': 0.25, 'C': 0.19, 'T': 0.33, 'G': 0.23, 'N': 0.0},
         {'A': 0.23, 'C': 0.25, 'T': 0.27, 'G': 0.25, 'N': 0.0},
         {'A': 0.21, 'C': 0.30, 'T': 0.26, 'G': 0.23, 'N': 0.0}]
    :param 'A', 'T', 'G', 'C', 'N' letters: nucleotides to consider
    :params '' title: title of the plot
    :params None axe: matplotlib axe object
    :params 1 quality: quality modifier
    :params None savefig: if set save the plot to the file at the specified path
       (the format of the file "pdf", "png"... will be infered from the file extension)
    :params 1.25 lwmodif: modifier for linewith of the drown letters.
    :params True plot: draw plot, otherwise only returns proportions.
    :params True errorbar: draw error bar, that are equal to the correction for
       small samples

    :returns: a table (list of list) with the proportions of each nucleotide at
       each position
    """
    xoffset = 0.003 * quality
    yoffset = 0.030 * quality
    letterw = 0.75

    qlmodif = lwmodif * quality / 5.
    halfw   = letterw / 2.

    if not seq_count and seqs:
        seq_count, col_count = nucleotide_content(
            seqs, letters=letters, remove_gap_only=remove_gap_only,
            min_count=min_count)
    elif not seq_count:
        raise Exception('ERROR: should input sequences or dictionary of '
                        'nucleotide content')

    if not plot:
        return seq_count

    np.seterr(divide='ignore')

    if nseq is None:
        if seqs:
            nseq = len(seqs)
        elif errorbar:
            raise Exception("ERROR: can't display error bar without sample "
                            "size, provide nseq")
    def lw(val):
        return ((val + np.log(val) + 7) * qlmodif) if val else 0.

    def A(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        lwh = lw(h)
        axe.plot([x, x + halfw, x + letterw ], [y, y + h, y], color='green', lw=lwh)
        axe.plot([x + letterw * 1 / 4, x + letterw * 3 / 4], [y + h  * 1 / 3] * 2,
                 color='green', lw=lwh)

    def T(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        lwh = lw(h)
        axe.plot([x + halfw ] * 2, [y, y + h] , color='red', lw=lwh)
        axe.plot([x, x + letterw]  , [y + h] * 2, color='red', lw=lwh)

    Gcircle = np.linspace(np.pi * 0.25, np.pi * 1.9, 20 * quality)
    xG = np.cos(Gcircle)
    yG = np.sin(Gcircle)
    def G(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        halfh = h / 2.
        xGw = x + xG * halfw + halfw
        yGh = y + yG * halfh + halfh
        lwh = lw(h)
        axe.plot(xGw, yGh, color='orange', lw=lwh)
        axe.plot([xGw[-1]          , xGw[-1]           , xGw[-1] - letterw * 0.4 ],
                 [yGh[-1] - h * 0.3, yGh[-1] + h * 0.05, yGh[-1] + h       * 0.05],
                color='orange', lw=lwh)

    Ccircle = np.linspace(np.pi * 0.2, np.pi * 1.8, 20 * quality)
    xC = np.cos(Ccircle)
    yC = np.sin(Ccircle)
    def C(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        axe.plot(x + xC * halfw + halfw,
                 y + yC * h / 2.+ h / 2., color='blue', lw=lw(h))

    def N(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        axe.plot([x, x, x + letterw, x + letterw], [y, y + h, y, y + h], color='grey', lw=lw(h))

    if not axe:
        fig = plt.figure(figsize=(len(seq_count) * 0.15 * quality, 1.75 * quality))
        axe = fig.add_subplot(111)

    # draw_letter_functions = {'A':A, 'T': T, 'G': G, 'C': C, 'N': N}
    draw_letter_functions = {'A':A, 'T': T, 'G': G, 'C': C}
    nchars = 4.  # nucleotides

    if errorbar:
        # get_err = lambda x: (1. / np.log(2) * (4 - 1.) / (2. * col_count[x]))
        trans = 1. / np.log(2) * (nchars - 1.) / 2.
        get_err = lambda x: trans / col_count[x]
    else:
        get_err = lambda x: 0

    for npos, position in enumerate(seq_count):
        offset = h = 0
        en = get_err(npos)
        hi = - sum(fi * np.log2(fi) for fi in position.values() if fi)
        ri = np.log2(nchars) - (hi + en)
        for letter, f in sorted(position.iteritems(), key=lambda x: x[1]):
            if not f:
                continue
            h =  f * ri
            x = npos + xoffset
            y = offset
            draw_letter_functions[letter](x, y, h)
            offset += h
        if errorbar:  # only over last letter
            plt.plot([x + halfw, x + halfw], [y + h + en, max(y + h - en, 0)],
                     color='grey')
            plt.plot([x + halfw - 0.1, x + halfw + 0.1], [y + h + en, y + h + en],
                     color='grey')
            if y + h - en > 0:
                plt.plot([x + halfw - 0.1, x + halfw + 0.1], [y + h - en] * 2,
                         color='grey')

    # axes
    axe.axis('off')
    axe.plot([-0.4, -0.1, -0.1, -0.4], [ylim[0], ylim[0], ylim[1], ylim[1]], color='k')
    for i in range(3):
        axe.text(-0.5, ylim[0] + (ylim[1] - ylim[0]) / 2. * i,
                 str(ylim[0] + (ylim[1] - ylim[0]) / 2. * i),
                 va='center', ha='right', size=6 * quality)
    axe.text(ylim[0] - 1.5, 1, 'bits', va='center', ha='right', rotation=90,
             size=9 * quality)
    axe.plot([-0.4, -0.1], [(ylim[1] - ylim[0]) / 2.] * 2, color='k')
    for i in xrange(1, npos + 2):
        axe.text(i - 0.5, ylim[0] - 0.05, str(i), va='top', ha='center',
                 size=6 * quality, rotation=90)
    _ = axe.set_xlim(-1, npos + 1.)
    _ = axe.set_ylim(ylim[0] - .5, ylim[1] + 3 * yoffset)
    # title
    axe.set_title(title)
    if savefig:
        plt.savefig(savefig, format=savefig.split('.')[-1])
        plt.close('all')
    return seq_count
