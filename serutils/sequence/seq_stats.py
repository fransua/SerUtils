"""
"""

try:
    from itertools import zip_longest
except ImportError:
    from itertools import izip_longest as zip_longest
from random import random, seed
from bisect import bisect_right as bisect

import numpy as np
from matplotlib import pyplot as plt


def generate_random_genomic_positions(coordinates=None, sequences=None,
                                      num=1, seed_num=1):
    seed(seed_num)
    if not coordinates:
        if sequences:
            coordinates = dict((c, len(sequences[c])) for c in sequences)
        else:
            raise Exception('ERROR: at least one of coordinates or sequences should be given!!')

    total_length = sum(v for v in coordinates.values())

    positions = [0]
    chroms = []
    total = 0
    for c in sorted(coordinates.keys(), key=lambda x: coordinates[x]):
        total += coordinates[c]
        positions.append(total)
        chroms.append(c)

    if sequences:
        count = 0
        while count < num:
            pos = int(random() * total_length)
            idx = bisect(positions, pos) - 1
            c, pos = chroms[idx], pos - positions[idx]
            if sequences[c][pos] == 'N':
                continue
            yield (c, pos + 1)
            count += 1
    else:
        for _ in range(num):
            pos = int(random() * total_length)
            idx = bisect(positions, pos) - 1
            yield (chroms[idx], pos - positions[idx] + 1)


def nucleotide_content(seqs, letters=('A', 'T', 'G', 'C', 'N'), remove_gap_only=True, min_count=1):
    """
    :params None seqs: list of sequences
    :param 'A', 'T', 'G', 'C', 'N' letters: nucleotides to consider

    :returns: list of dictionaries of nucleotide proportions per sequence.
    """
    seq_count = []
    col_count = []
    lencol = float(len(seqs))
    for col in zip_longest(*seqs, fillvalue='N'):
        nchars = lencol - col.count('-')
        if nchars < min_count:
            if not remove_gap_only:
                seq_count.append(dict([(let, 0) for let in letters]))
                col_count.append(nchars)
            continue
        col_count.append(nchars)
        seq_count.append(dict([(let, col.count(let) / nchars) for let in letters]))
    return seq_count, col_count


def seq_logo(seqs=None, seq_count=None, letters=('A', 'T', 'G', 'C', 'N'),
             nseq=None, title='', axe=None, quality=1, plot=True, ylim=(0, 2), alpha=1,
             lwmodif=1.25, remove_gap_only=True, min_count=1, errorbar=True, savefig=None):
    """
    Draw a sequence motif according to an input list of sequences,
    https://en.wikipedia.org/wiki/Sequence_logo

    :params None seqs: list of sequences
    :params None seq_count: list of dictionaries of nucleotide proportions per
        sequence (generated by nucleotide_content function) in the form:
        [{'A': 0.29, 'C': 0.22, 'T': 0.24, 'G': 0.25, 'N': 0.0},
         {'A': 0.26, 'C': 0.27, 'T': 0.24, 'G': 0.23, 'N': 0.0},
         {'A': 0.32, 'C': 0.25, 'T': 0.17, 'G': 0.26, 'N': 0.0},
         {'A': 0.32, 'C': 0.24, 'T': 0.21, 'G': 0.23, 'N': 0.0},
         {'A': 0.29, 'C': 0.21, 'T': 0.25, 'G': 0.25, 'N': 0.0},
         {'A': 0.25, 'C': 0.28, 'T': 0.26, 'G': 0.21, 'N': 0.0},
         {'A': 0.21, 'C': 0.25, 'T': 0.34, 'G': 0.20, 'N': 0.0},
         {'A': 0.25, 'C': 0.19, 'T': 0.33, 'G': 0.23, 'N': 0.0},
         {'A': 0.23, 'C': 0.25, 'T': 0.27, 'G': 0.25, 'N': 0.0},
         {'A': 0.21, 'C': 0.30, 'T': 0.26, 'G': 0.23, 'N': 0.0}]
    :param 'A', 'T', 'G', 'C', 'N' letters: nucleotides to consider
    :params '' title: title of the plot
    :params None axe: matplotlib axe object
    :params 1 quality: quality modifier
    :params None savefig: if set save the plot to the file at the specified path
       (the format of the file "pdf", "png"... will be infered from the file extension)
    :params 1.25 lwmodif: modifier for linewith of the drown letters.
    :params True plot: draw plot, otherwise only returns proportions.
    :params True errorbar: draw error bar, that are equal to the correction for
       small samples

    :returns: a table (list of list) with the proportions of each nucleotide at
       each position
    """
    xoffset = 0.003 * quality
    yoffset = 0.030 * quality
    letterw = 0.75

    qlmodif = lwmodif * quality / 5.
    halfw   = letterw / 2.

    if isinstance(seqs, list):
        no_seqs = False if seqs else True
    elif seqs is None:
        no_seqs = seqs.empty
    elif len(seqs) == 0:
        no_seqs = seqs.empty
    else:
        raise Exception('ERROR: what is seqs?')

    if seq_count is None and not no_seqs:
        seq_count, col_count = nucleotide_content(
            seqs, letters=letters, remove_gap_only=remove_gap_only,
            min_count=min_count)
    elif not seq_count:
        raise Exception('ERROR: should input sequences or dictionary of '
                        'nucleotide content')

    if not plot:
        return seq_count

    np.seterr(divide='ignore')

    if nseq is None:
        if not no_seqs:
            nseq = len(seqs)
        elif errorbar:
            raise Exception("ERROR: can't display error bar without sample "
                            "size, provide nseq")
    def lw(val):
        return ((val + np.log(val) + 7) * qlmodif) if val else 0.

    def A(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        lwh = lw(h)
        axe.plot([x, x + halfw, x + letterw ], [y, y + h, y], color='green', alpha=alpha, lw=lwh)
        axe.plot([x + letterw * 1 / 4, x + letterw * 3 / 4], [y + h  * 1 / 3] * 2,
                 color='green', alpha=alpha, lw=lwh)

    def T(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        lwh = lw(h)
        axe.plot([x + halfw ] * 2, [y, y + h] , color='red', alpha=alpha, lw=lwh)
        axe.plot([x, x + letterw]  , [y + h] * 2, color='red', alpha=alpha, lw=lwh)

    Gcircle = np.linspace(np.pi * 0.25, np.pi * 1.9, 20 * quality)
    xG = np.cos(Gcircle)
    yG = np.sin(Gcircle)
    def G(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        halfh = h / 2.
        xGw = x + xG * halfw + halfw
        yGh = y + yG * halfh + halfh
        lwh = lw(h)
        axe.plot(xGw, yGh, color='orange', alpha=alpha, lw=lwh)
        axe.plot([xGw[-1]          , xGw[-1]           , xGw[-1] - letterw * 0.4 ],
                 [yGh[-1] - h * 0.3, yGh[-1] + h * 0.05, yGh[-1] + h       * 0.05],
                color='orange', alpha=alpha, lw=lwh)

    Ccircle = np.linspace(np.pi * 0.2, np.pi * 1.8, 20 * quality)
    xC = np.cos(Ccircle)
    yC = np.sin(Ccircle)
    def C(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        axe.plot(x + xC * halfw + halfw,
                 y + yC * h / 2.+ h / 2., color='blue', alpha=alpha, lw=lw(h))

    def N(x, y, h):
        if yoffset < h:
            y += yoffset
            h -= yoffset
        axe.plot([x, x, x + letterw, x + letterw], [y, y + h, y, y + h], color='grey', alpha=alpha, lw=lw(h))

    given_axe = True
    if not axe:
        given_axe = False
        fig = plt.figure(figsize=(len(seq_count) * 0.15 * quality, 1.75 * quality))
        axe = fig.add_subplot(111)

    # draw_letter_functions = {'A':A, 'T': T, 'G': G, 'C': C, 'N': N}
    draw_letter_functions = {'A':A, 'T': T, 'G': G, 'C': C}
    nchars = 4.  # nucleotides

    if errorbar:
        # get_err = lambda x: (1. / np.log(2) * (4 - 1.) / (2. * col_count[x]))
        trans = 1. / np.log(2) * (nchars - 1.) / 2.
        get_err = lambda x: trans / col_count[x]
    else:
        get_err = lambda x: 0

    for npos, position in enumerate(seq_count):
        offset = h = 0
        en = get_err(npos)
        hi = - sum(fi * np.log2(fi) for fi in position.values() if fi)
        ri = np.log2(nchars) - (hi + en)
        for letter, f in sorted(position.items(), key=lambda x: x[1]):
            if not f:
                continue
            h =  f * ri
            x = npos + xoffset
            y = offset
            draw_letter_functions.get(letter, lambda _, __, ___: None)(x, y, h)
            offset += h
        if errorbar:  # only over last letter
            plt.plot([x + halfw, x + halfw], [y + h + en, max(y + h - en, 0)],
                     alpha=alpha, color='grey')
            plt.plot([x + halfw - 0.1, x + halfw + 0.1], [y + h + en, y + h + en],
                     alpha=alpha, color='grey')
            if y + h - en > 0:
                plt.plot([x + halfw - 0.1, x + halfw + 0.1], [y + h - en] * 2,
                         alpha=alpha, color='grey')

    # axes
    axe.axis('off')
    axe.plot([-0.4, -0.1, -0.1, -0.4], [ylim[0], ylim[0], ylim[1], ylim[1]], alpha=alpha, color='k')
    for i in range(3):
        axe.text(-0.5, ylim[0] + (ylim[1] - ylim[0]) / 2. * i,
                 str(ylim[0] + (ylim[1] - ylim[0]) / 2. * i),
                 va='center', ha='right', size=6 * quality, alpha=alpha)
    axe.text(ylim[0] - 0.5 - len(seq_count) / 50., 1, 'bits', va='center', ha='right', rotation=90,
             size=9 * quality, alpha=alpha)
    axe.plot([-0.4, -0.1], [(ylim[1] - ylim[0]) / 2.] * 2, alpha=alpha, color='k')
    for i in range(1, npos + 2):
        axe.text(i - 0.5, ylim[0] - 0.05, str(i), va='top', ha='center',
                 size=6 * quality, rotation=90, alpha=alpha)
    _ = axe.set_xlim(-1, npos + 1.)
    _ = axe.set_ylim(ylim[0] - (0 if given_axe else 0.5), ylim[1] + 3 * yoffset)
    # title
    axe.set_title(title, alpha=alpha)
    if savefig:
        plt.savefig(savefig, format=savefig.split('.')[-1])
        plt.close('all')
    return seq_count
